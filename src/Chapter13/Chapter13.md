# Chapter 13 동시성

---

## 동시성이 필요한 이유

동시성은 결합을 없애는 전략이다. → 무엇과 언제를 분리하는 전략.

단일 스레드 프로그램의 경우 무엇과 언제가 서로 밀접하다.

→ 호출 스택을 살펴보면 프로그램 상태가 곧바로 드러난다.

**무엇과 언제를 분리하게 되면 어플리케이션 구조와 효율이 극적으로 나아진다.**

→ 프로그램을 하나의 루프가 아닌 작은 여러 협력 프로그램으로 볼 수 있다.

→ 시스템을 이해하기 쉽고 문제를 분리하기 쉬워진다.

**동시성을 이용하여 응답 시간과 작업 처리량을 개선할 수 있다.**

하지만 동시성은 그렇게 간단한 문제가 아니다. → 각별히 주의하지 않으면 문제가 발생

### 동시성의 미신과 오해

- 동시성은 항상 성능을 높여준다.
  **동시성은 때로 성능을 높여준다.**
  → 대기 시간이 아주 길어 여러 스레드가 프로세서를 공유할 수 있는 경우, 여러 프로세서가 동시에 처리할 독립적인 연산이 충분히 많은 경우 → 그리 일반적인 상황이 아님
- 동시성을 구현해도 설계는 변하지 않는다
  **무엇과 언제를 분리하면 설계는 판이하게 달라진다.**
- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다
  실제로 컨테이너가 어떻게 동작하는지, 어떻게 동시 수정, 데드락 등과 같은 문제를 피할 수 있는지를 알아야만 한다.

이번에는 동시성과 관련된 타당한 생각이다.

- 동시성은 다소 부하를 일으킨다. → 성능 측면에서 부하가 걸리고, 코드도 더 짜야 한다.
- 동시성은 복잡하다.
- 일반적으로 동시성 버그는 재현하기 어렵다
- 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.

---

## 난관

동시성을 구현하기 어려운 이유를 알아보자

```java
public class ClassWithThreadingProblem {
    private int lastIdUsed;
    
    public ClassWithThreadingProblem(int lastIdUsed) {
        this.lastIdUsed = lastIdUsed;
    }
    
    public int getNextId() {
        return ++lastIdUsed;
    }
}
```

두 스레드가 lastIdUsed 필드를 공유하고 getNextId() 메서드를 호출한다고 가정하자.

이 때 결과는 셋 중 하나이다.

- thread1: 43 thread2: 44 laseIdUsed: 44
- thread1: 44 thread2: 43 laseIdUsed: 44
- thread1: 43 thread2: 43 laseIdUsed: 43

두 스레드가 같은 변수를 동시에 참조해 세 번째와 같은 이상한 결과가 나오게 된다. 심지어 이 결과가 언제 나올지도 예측이 안된다.

자바가 바이트 코드를 처리하는 방식에서 나오는 문제이다.

상세한 내용은 부록을 참고하자

---

## 동시성 방어 원칙